/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mocklora.h"

static const char* CMockString_buf = "buf";
static const char* CMockString_buffer = "buffer";
static const char* CMockString_buffer_size = "buffer_size";
static const char* CMockString_buffer_to_string = "buffer_to_string";
static const char* CMockString_data_size = "data_size";
static const char* CMockString_destination = "destination";
static const char* CMockString_destination_size = "destination_size";
static const char* CMockString_dev = "dev";
static const char* CMockString_get_data_size = "get_data_size";
static const char* CMockString_len = "len";
static const char* CMockString_loginfo = "loginfo";
static const char* CMockString_lora_receive = "lora_receive";
static const char* CMockString_msg = "msg";
static const char* CMockString_pack_packet = "pack_packet";
static const char* CMockString_packet = "packet";
static const char* CMockString_print_buffer = "print_buffer";
static const char* CMockString_spidev_close = "spidev_close";
static const char* CMockString_spidev_open = "spidev_open";
static const char* CMockString_temp_init = "temp_init";
static const char* CMockString_type = "type";

typedef struct _CMOCK_spidev_open_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  const char* Expected_dev;

} CMOCK_spidev_open_CALL_INSTANCE;

typedef struct _CMOCK_spidev_close_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_spidev_close_CALL_INSTANCE;

typedef struct _CMOCK_print_buffer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t* Expected_buf;
  uint8_t Expected_len;

} CMOCK_print_buffer_CALL_INSTANCE;

typedef struct _CMOCK_buffer_to_string_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t* Expected_buffer;
  size_t Expected_buffer_size;
  char* Expected_destination;
  size_t Expected_destination_size;

} CMOCK_buffer_to_string_CALL_INSTANCE;

typedef struct _CMOCK_loginfo_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  int ReturnVal;
  const char* Expected_msg;

} CMOCK_loginfo_CALL_INSTANCE;

typedef struct _CMOCK_lora_receive_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  packet_t* Expected_packet;

} CMOCK_lora_receive_CALL_INSTANCE;

typedef struct _CMOCK_temp_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;

} CMOCK_temp_init_CALL_INSTANCE;

typedef struct _CMOCK_pack_packet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t* Expected_buffer;
  packet_t* Expected_packet;
  size_t Expected_data_size;

} CMOCK_pack_packet_CALL_INSTANCE;

typedef struct _CMOCK_get_data_size_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  size_t ReturnVal;
  DataType Expected_type;

} CMOCK_get_data_size_CALL_INSTANCE;

static struct MockloraInstance
{
  CMOCK_MEM_INDEX_TYPE spidev_open_CallInstance;
  CMOCK_MEM_INDEX_TYPE spidev_close_CallInstance;
  CMOCK_MEM_INDEX_TYPE print_buffer_CallInstance;
  CMOCK_MEM_INDEX_TYPE buffer_to_string_CallInstance;
  CMOCK_MEM_INDEX_TYPE loginfo_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_receive_CallInstance;
  CMOCK_MEM_INDEX_TYPE temp_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE pack_packet_CallInstance;
  CMOCK_MEM_INDEX_TYPE get_data_size_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mocklora_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.spidev_open_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spidev_open);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.spidev_close_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_spidev_close);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.print_buffer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_print_buffer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.buffer_to_string_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_buffer_to_string);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.loginfo_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_loginfo);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_receive_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_receive);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.temp_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_temp_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.pack_packet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_pack_packet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.get_data_size_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_get_data_size);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mocklora_Init(void)
{
  Mocklora_Destroy();
}

void Mocklora_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

int spidev_open(const char* dev)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spidev_open_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spidev_open);
  cmock_call_instance = (CMOCK_spidev_open_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spidev_open_CallInstance);
  Mock.spidev_open_CallInstance = CMock_Guts_MemNext(Mock.spidev_open_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_spidev_open,CMockString_dev);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_dev, dev, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_spidev_open(CMOCK_spidev_open_CALL_INSTANCE* cmock_call_instance, const char* dev);
void CMockExpectParameters_spidev_open(CMOCK_spidev_open_CALL_INSTANCE* cmock_call_instance, const char* dev)
{
  cmock_call_instance->Expected_dev = dev;
}

void spidev_open_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* dev, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spidev_open_CALL_INSTANCE));
  CMOCK_spidev_open_CALL_INSTANCE* cmock_call_instance = (CMOCK_spidev_open_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spidev_open_CallInstance = CMock_Guts_MemChain(Mock.spidev_open_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_spidev_open(cmock_call_instance, dev);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

void spidev_close(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_spidev_close_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_spidev_close);
  cmock_call_instance = (CMOCK_spidev_close_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.spidev_close_CallInstance);
  Mock.spidev_close_CallInstance = CMock_Guts_MemNext(Mock.spidev_close_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void spidev_close_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_spidev_close_CALL_INSTANCE));
  CMOCK_spidev_close_CALL_INSTANCE* cmock_call_instance = (CMOCK_spidev_close_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.spidev_close_CallInstance = CMock_Guts_MemChain(Mock.spidev_close_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

void print_buffer(uint8_t* buf, uint8_t len)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_print_buffer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_print_buffer);
  cmock_call_instance = (CMOCK_print_buffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.print_buffer_CallInstance);
  Mock.print_buffer_CallInstance = CMock_Guts_MemNext(Mock.print_buffer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_print_buffer,CMockString_buf);
    if (cmock_call_instance->Expected_buf == NULL)
      { UNITY_TEST_ASSERT_NULL(buf, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buf, buf, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_print_buffer,CMockString_len);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_len, len, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_print_buffer(CMOCK_print_buffer_CALL_INSTANCE* cmock_call_instance, uint8_t* buf, uint8_t len);
void CMockExpectParameters_print_buffer(CMOCK_print_buffer_CALL_INSTANCE* cmock_call_instance, uint8_t* buf, uint8_t len)
{
  cmock_call_instance->Expected_buf = buf;
  cmock_call_instance->Expected_len = len;
}

void print_buffer_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t* buf, uint8_t len)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_print_buffer_CALL_INSTANCE));
  CMOCK_print_buffer_CALL_INSTANCE* cmock_call_instance = (CMOCK_print_buffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.print_buffer_CallInstance = CMock_Guts_MemChain(Mock.print_buffer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_print_buffer(cmock_call_instance, buf, len);
}

void buffer_to_string(uint8_t* buffer, size_t buffer_size, char* destination, size_t destination_size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_buffer_to_string_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_buffer_to_string);
  cmock_call_instance = (CMOCK_buffer_to_string_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.buffer_to_string_CallInstance);
  Mock.buffer_to_string_CallInstance = CMock_Guts_MemNext(Mock.buffer_to_string_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_buffer_to_string,CMockString_buffer);
    if (cmock_call_instance->Expected_buffer == NULL)
      { UNITY_TEST_ASSERT_NULL(buffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buffer, buffer, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_buffer_to_string,CMockString_buffer_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_buffer_size), (void*)(&buffer_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_buffer_to_string,CMockString_destination);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_destination, destination, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_buffer_to_string,CMockString_destination_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_destination_size), (void*)(&destination_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_buffer_to_string(CMOCK_buffer_to_string_CALL_INSTANCE* cmock_call_instance, uint8_t* buffer, size_t buffer_size, char* destination, size_t destination_size);
void CMockExpectParameters_buffer_to_string(CMOCK_buffer_to_string_CALL_INSTANCE* cmock_call_instance, uint8_t* buffer, size_t buffer_size, char* destination, size_t destination_size)
{
  cmock_call_instance->Expected_buffer = buffer;
  memcpy((void*)(&cmock_call_instance->Expected_buffer_size), (void*)(&buffer_size),
         sizeof(size_t[sizeof(buffer_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
  cmock_call_instance->Expected_destination = destination;
  memcpy((void*)(&cmock_call_instance->Expected_destination_size), (void*)(&destination_size),
         sizeof(size_t[sizeof(destination_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void buffer_to_string_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t* buffer, size_t buffer_size, char* destination, size_t destination_size)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_buffer_to_string_CALL_INSTANCE));
  CMOCK_buffer_to_string_CALL_INSTANCE* cmock_call_instance = (CMOCK_buffer_to_string_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.buffer_to_string_CallInstance = CMock_Guts_MemChain(Mock.buffer_to_string_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_buffer_to_string(cmock_call_instance, buffer, buffer_size, destination, destination_size);
}

int loginfo(const char* msg)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_loginfo_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_loginfo);
  cmock_call_instance = (CMOCK_loginfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.loginfo_CallInstance);
  Mock.loginfo_CallInstance = CMock_Guts_MemNext(Mock.loginfo_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_loginfo,CMockString_msg);
    UNITY_TEST_ASSERT_EQUAL_STRING(cmock_call_instance->Expected_msg, msg, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_loginfo(CMOCK_loginfo_CALL_INSTANCE* cmock_call_instance, const char* msg);
void CMockExpectParameters_loginfo(CMOCK_loginfo_CALL_INSTANCE* cmock_call_instance, const char* msg)
{
  cmock_call_instance->Expected_msg = msg;
}

void loginfo_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, const char* msg, int cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_loginfo_CALL_INSTANCE));
  CMOCK_loginfo_CALL_INSTANCE* cmock_call_instance = (CMOCK_loginfo_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.loginfo_CallInstance = CMock_Guts_MemChain(Mock.loginfo_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_loginfo(cmock_call_instance, msg);
  cmock_call_instance->ReturnVal = cmock_to_return;
}

lora_status_t lora_receive(packet_t* packet)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_receive_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_receive);
  cmock_call_instance = (CMOCK_lora_receive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_receive_CallInstance);
  Mock.lora_receive_CallInstance = CMock_Guts_MemNext(Mock.lora_receive_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_receive,CMockString_packet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_packet), (void*)(packet), sizeof(packet_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_receive(CMOCK_lora_receive_CALL_INSTANCE* cmock_call_instance, packet_t* packet);
void CMockExpectParameters_lora_receive(CMOCK_lora_receive_CALL_INSTANCE* cmock_call_instance, packet_t* packet)
{
  cmock_call_instance->Expected_packet = packet;
}

void lora_receive_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, packet_t* packet, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_receive_CALL_INSTANCE));
  CMOCK_lora_receive_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_receive_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_receive_CallInstance = CMock_Guts_MemChain(Mock.lora_receive_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_receive(cmock_call_instance, packet);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t temp_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_temp_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_temp_init);
  cmock_call_instance = (CMOCK_temp_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.temp_init_CallInstance);
  Mock.temp_init_CallInstance = CMock_Guts_MemNext(Mock.temp_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void temp_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_temp_init_CALL_INSTANCE));
  CMOCK_temp_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_temp_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.temp_init_CallInstance = CMock_Guts_MemChain(Mock.temp_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

void pack_packet(uint8_t* buffer, packet_t* packet, size_t data_size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_pack_packet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_pack_packet);
  cmock_call_instance = (CMOCK_pack_packet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.pack_packet_CallInstance);
  Mock.pack_packet_CallInstance = CMock_Guts_MemNext(Mock.pack_packet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_pack_packet,CMockString_buffer);
    if (cmock_call_instance->Expected_buffer == NULL)
      { UNITY_TEST_ASSERT_NULL(buffer, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buffer, buffer, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_pack_packet,CMockString_packet);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(cmock_call_instance->Expected_packet), (void*)(packet), sizeof(packet_t), cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_pack_packet,CMockString_data_size);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size), sizeof(size_t), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
}

void CMockExpectParameters_pack_packet(CMOCK_pack_packet_CALL_INSTANCE* cmock_call_instance, uint8_t* buffer, packet_t* packet, size_t data_size);
void CMockExpectParameters_pack_packet(CMOCK_pack_packet_CALL_INSTANCE* cmock_call_instance, uint8_t* buffer, packet_t* packet, size_t data_size)
{
  cmock_call_instance->Expected_buffer = buffer;
  cmock_call_instance->Expected_packet = packet;
  memcpy((void*)(&cmock_call_instance->Expected_data_size), (void*)(&data_size),
         sizeof(size_t[sizeof(data_size) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

void pack_packet_CMockExpect(UNITY_LINE_TYPE cmock_line, uint8_t* buffer, packet_t* packet, size_t data_size)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_pack_packet_CALL_INSTANCE));
  CMOCK_pack_packet_CALL_INSTANCE* cmock_call_instance = (CMOCK_pack_packet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.pack_packet_CallInstance = CMock_Guts_MemChain(Mock.pack_packet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_pack_packet(cmock_call_instance, buffer, packet, data_size);
}

size_t get_data_size(DataType type)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_get_data_size_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_get_data_size);
  cmock_call_instance = (CMOCK_get_data_size_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.get_data_size_CallInstance);
  Mock.get_data_size_CallInstance = CMock_Guts_MemNext(Mock.get_data_size_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_get_data_size,CMockString_type);
    UNITY_TEST_ASSERT_EQUAL_MEMORY((void*)(&cmock_call_instance->Expected_type), (void*)(&type), sizeof(DataType), cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_get_data_size(CMOCK_get_data_size_CALL_INSTANCE* cmock_call_instance, DataType type);
void CMockExpectParameters_get_data_size(CMOCK_get_data_size_CALL_INSTANCE* cmock_call_instance, DataType type)
{
  memcpy((void*)(&cmock_call_instance->Expected_type), (void*)(&type),
         sizeof(DataType[sizeof(type) == sizeof(DataType) ? 1 : -1])); /* add DataType to :treat_as_array if this causes an error */
}

void get_data_size_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, DataType type, size_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_get_data_size_CALL_INSTANCE));
  CMOCK_get_data_size_CALL_INSTANCE* cmock_call_instance = (CMOCK_get_data_size_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.get_data_size_CallInstance = CMock_Guts_MemChain(Mock.get_data_size_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_get_data_size(cmock_call_instance, type);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(size_t[sizeof(cmock_to_return) == sizeof(size_t) ? 1 : -1])); /* add size_t to :treat_as_array if this causes an error */
}

