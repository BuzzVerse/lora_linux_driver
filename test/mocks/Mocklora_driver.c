/* AUTOGENERATED FILE. DO NOT EDIT. */
#include <string.h>
#include <stdlib.h>
#include <setjmp.h>
#include "cmock.h"
#include "Mocklora_driver.h"

static const char* CMockString_buf = "buf";
static const char* CMockString_cr = "cr";
static const char* CMockString_crc_error = "crc_error";
static const char* CMockString_denominator = "denominator";
static const char* CMockString_dio = "dio";
static const char* CMockString_frequency = "frequency";
static const char* CMockString_irq_flags = "irq_flags";
static const char* CMockString_len = "len";
static const char* CMockString_length = "length";
static const char* CMockString_level = "level";
static const char* CMockString_lora_close = "lora_close";
static const char* CMockString_lora_disable_crc = "lora_disable_crc";
static const char* CMockString_lora_driver_init = "lora_driver_init";
static const char* CMockString_lora_dump_registers = "lora_dump_registers";
static const char* CMockString_lora_enable_crc = "lora_enable_crc";
static const char* CMockString_lora_explicit_header_mode = "lora_explicit_header_mode";
static const char* CMockString_lora_get_bandwidth = "lora_get_bandwidth";
static const char* CMockString_lora_get_coding_rate = "lora_get_coding_rate";
static const char* CMockString_lora_get_dio_mapping = "lora_get_dio_mapping";
static const char* CMockString_lora_get_irq = "lora_get_irq";
static const char* CMockString_lora_get_preamble_length = "lora_get_preamble_length";
static const char* CMockString_lora_get_spreading_factor = "lora_get_spreading_factor";
static const char* CMockString_lora_idle_mode = "lora_idle_mode";
static const char* CMockString_lora_implicit_header_mode = "lora_implicit_header_mode";
static const char* CMockString_lora_packet_lost = "lora_packet_lost";
static const char* CMockString_lora_packet_rssi = "lora_packet_rssi";
static const char* CMockString_lora_packet_snr = "lora_packet_snr";
static const char* CMockString_lora_read_reg = "lora_read_reg";
static const char* CMockString_lora_read_reg_buffer = "lora_read_reg_buffer";
static const char* CMockString_lora_receive_mode = "lora_receive_mode";
static const char* CMockString_lora_receive_packet = "lora_receive_packet";
static const char* CMockString_lora_received = "lora_received";
static const char* CMockString_lora_send_packet = "lora_send_packet";
static const char* CMockString_lora_set_bandwidth = "lora_set_bandwidth";
static const char* CMockString_lora_set_coding_rate = "lora_set_coding_rate";
static const char* CMockString_lora_set_dio_mapping = "lora_set_dio_mapping";
static const char* CMockString_lora_set_frequency = "lora_set_frequency";
static const char* CMockString_lora_set_preamble_length = "lora_set_preamble_length";
static const char* CMockString_lora_set_spreading_factor = "lora_set_spreading_factor";
static const char* CMockString_lora_set_sync_word = "lora_set_sync_word";
static const char* CMockString_lora_set_tx_power = "lora_set_tx_power";
static const char* CMockString_lora_sleep_mode = "lora_sleep_mode";
static const char* CMockString_lora_write_reg = "lora_write_reg";
static const char* CMockString_lora_write_reg_buffer = "lora_write_reg_buffer";
static const char* CMockString_mapping = "mapping";
static const char* CMockString_mode = "mode";
static const char* CMockString_preamble = "preamble";
static const char* CMockString_received = "received";
static const char* CMockString_reg = "reg";
static const char* CMockString_return_len = "return_len";
static const char* CMockString_rssi = "rssi";
static const char* CMockString_sbw = "sbw";
static const char* CMockString_sf = "sf";
static const char* CMockString_size = "size";
static const char* CMockString_snr = "snr";
static const char* CMockString_sw = "sw";
static const char* CMockString_val = "val";

typedef struct _CMOCK_lora_write_reg_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_reg;
  uint8_t Expected_val;

} CMOCK_lora_write_reg_CALL_INSTANCE;

typedef struct _CMOCK_lora_write_reg_buffer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_reg;
  uint8_t* Expected_val;
  uint8_t Expected_len;

} CMOCK_lora_write_reg_buffer_CALL_INSTANCE;

typedef struct _CMOCK_lora_read_reg_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_reg;
  uint8_t* Expected_val;

} CMOCK_lora_read_reg_CALL_INSTANCE;

typedef struct _CMOCK_lora_read_reg_buffer_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_reg;
  uint8_t* Expected_val;
  uint8_t Expected_len;

} CMOCK_lora_read_reg_buffer_CALL_INSTANCE;

typedef struct _CMOCK_lora_explicit_header_mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;

} CMOCK_lora_explicit_header_mode_CALL_INSTANCE;

typedef struct _CMOCK_lora_implicit_header_mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_size;

} CMOCK_lora_implicit_header_mode_CALL_INSTANCE;

typedef struct _CMOCK_lora_idle_mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;

} CMOCK_lora_idle_mode_CALL_INSTANCE;

typedef struct _CMOCK_lora_sleep_mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;

} CMOCK_lora_sleep_mode_CALL_INSTANCE;

typedef struct _CMOCK_lora_receive_mode_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;

} CMOCK_lora_receive_mode_CALL_INSTANCE;

typedef struct _CMOCK_lora_set_tx_power_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_level;

} CMOCK_lora_set_tx_power_CALL_INSTANCE;

typedef struct _CMOCK_lora_set_frequency_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  long Expected_frequency;

} CMOCK_lora_set_frequency_CALL_INSTANCE;

typedef struct _CMOCK_lora_set_spreading_factor_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_sf;

} CMOCK_lora_set_spreading_factor_CALL_INSTANCE;

typedef struct _CMOCK_lora_get_spreading_factor_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t* Expected_sf;

} CMOCK_lora_get_spreading_factor_CALL_INSTANCE;

typedef struct _CMOCK_lora_set_dio_mapping_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_dio;
  uint8_t Expected_mode;

} CMOCK_lora_set_dio_mapping_CALL_INSTANCE;

typedef struct _CMOCK_lora_get_dio_mapping_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_dio;
  uint8_t* Expected_mapping;

} CMOCK_lora_get_dio_mapping_CALL_INSTANCE;

typedef struct _CMOCK_lora_set_bandwidth_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_sbw;

} CMOCK_lora_set_bandwidth_CALL_INSTANCE;

typedef struct _CMOCK_lora_get_bandwidth_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t* Expected_sbw;

} CMOCK_lora_get_bandwidth_CALL_INSTANCE;

typedef struct _CMOCK_lora_set_coding_rate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_denominator;

} CMOCK_lora_set_coding_rate_CALL_INSTANCE;

typedef struct _CMOCK_lora_get_coding_rate_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t* Expected_cr;

} CMOCK_lora_get_coding_rate_CALL_INSTANCE;

typedef struct _CMOCK_lora_set_preamble_length_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  long Expected_length;

} CMOCK_lora_set_preamble_length_CALL_INSTANCE;

typedef struct _CMOCK_lora_get_preamble_length_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  long* Expected_preamble;

} CMOCK_lora_get_preamble_length_CALL_INSTANCE;

typedef struct _CMOCK_lora_set_sync_word_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t Expected_sw;

} CMOCK_lora_set_sync_word_CALL_INSTANCE;

typedef struct _CMOCK_lora_enable_crc_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;

} CMOCK_lora_enable_crc_CALL_INSTANCE;

typedef struct _CMOCK_lora_disable_crc_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;

} CMOCK_lora_disable_crc_CALL_INSTANCE;

typedef struct _CMOCK_lora_driver_init_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;

} CMOCK_lora_driver_init_CALL_INSTANCE;

typedef struct _CMOCK_lora_send_packet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t* Expected_buf;
  uint8_t Expected_size;

} CMOCK_lora_send_packet_CALL_INSTANCE;

typedef struct _CMOCK_lora_receive_packet_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t* Expected_buf;
  uint8_t* Expected_return_len;
  uint8_t Expected_size;

} CMOCK_lora_receive_packet_CALL_INSTANCE;

typedef struct _CMOCK_lora_received_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  bool* Expected_received;
  bool* Expected_crc_error;

} CMOCK_lora_received_CALL_INSTANCE;

typedef struct _CMOCK_lora_get_irq_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t* Expected_irq_flags;

} CMOCK_lora_get_irq_CALL_INSTANCE;

typedef struct _CMOCK_lora_packet_lost_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  uint8_t ReturnVal;

} CMOCK_lora_packet_lost_CALL_INSTANCE;

typedef struct _CMOCK_lora_packet_rssi_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t* Expected_rssi;

} CMOCK_lora_packet_rssi_CALL_INSTANCE;

typedef struct _CMOCK_lora_packet_snr_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;
  uint8_t* Expected_snr;

} CMOCK_lora_packet_snr_CALL_INSTANCE;

typedef struct _CMOCK_lora_close_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;

} CMOCK_lora_close_CALL_INSTANCE;

typedef struct _CMOCK_lora_dump_registers_CALL_INSTANCE
{
  UNITY_LINE_TYPE LineNumber;
  lora_status_t ReturnVal;

} CMOCK_lora_dump_registers_CALL_INSTANCE;

static struct Mocklora_driverInstance
{
  CMOCK_MEM_INDEX_TYPE lora_write_reg_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_write_reg_buffer_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_read_reg_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_read_reg_buffer_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_explicit_header_mode_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_implicit_header_mode_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_idle_mode_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_sleep_mode_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_receive_mode_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_set_tx_power_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_set_frequency_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_set_spreading_factor_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_get_spreading_factor_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_set_dio_mapping_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_get_dio_mapping_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_set_bandwidth_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_get_bandwidth_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_set_coding_rate_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_get_coding_rate_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_set_preamble_length_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_get_preamble_length_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_set_sync_word_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_enable_crc_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_disable_crc_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_driver_init_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_send_packet_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_receive_packet_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_received_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_get_irq_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_packet_lost_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_packet_rssi_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_packet_snr_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_close_CallInstance;
  CMOCK_MEM_INDEX_TYPE lora_dump_registers_CallInstance;
} Mock;

extern jmp_buf AbortFrame;

void Mocklora_driver_Verify(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_MEM_INDEX_TYPE call_instance;
  call_instance = Mock.lora_write_reg_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_write_reg);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_write_reg_buffer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_write_reg_buffer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_read_reg_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_read_reg);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_read_reg_buffer_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_read_reg_buffer);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_explicit_header_mode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_explicit_header_mode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_implicit_header_mode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_implicit_header_mode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_idle_mode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_idle_mode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_sleep_mode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_sleep_mode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_receive_mode_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_receive_mode);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_set_tx_power_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_set_tx_power);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_set_frequency_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_set_frequency);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_set_spreading_factor_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_set_spreading_factor);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_get_spreading_factor_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_get_spreading_factor);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_set_dio_mapping_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_set_dio_mapping);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_get_dio_mapping_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_get_dio_mapping);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_set_bandwidth_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_set_bandwidth);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_get_bandwidth_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_get_bandwidth);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_set_coding_rate_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_set_coding_rate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_get_coding_rate_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_get_coding_rate);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_set_preamble_length_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_set_preamble_length);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_get_preamble_length_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_get_preamble_length);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_set_sync_word_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_set_sync_word);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_enable_crc_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_enable_crc);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_disable_crc_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_disable_crc);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_driver_init_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_driver_init);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_send_packet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_send_packet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_receive_packet_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_receive_packet);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_received_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_received);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_get_irq_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_get_irq);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_packet_lost_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_packet_lost);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_packet_rssi_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_packet_rssi);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_packet_snr_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_packet_snr);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_close_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_close);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
  call_instance = Mock.lora_dump_registers_CallInstance;
  if (CMOCK_GUTS_NONE != call_instance)
  {
    UNITY_SET_DETAIL(CMockString_lora_dump_registers);
    UNITY_TEST_FAIL(cmock_line, CMockStringCalledLess);
  }
}

void Mocklora_driver_Init(void)
{
  Mocklora_driver_Destroy();
}

void Mocklora_driver_Destroy(void)
{
  CMock_Guts_MemFreeAll();
  memset(&Mock, 0, sizeof(Mock));
}

lora_status_t lora_write_reg(uint8_t reg, uint8_t val)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_write_reg_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_write_reg);
  cmock_call_instance = (CMOCK_lora_write_reg_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_write_reg_CallInstance);
  Mock.lora_write_reg_CallInstance = CMock_Guts_MemNext(Mock.lora_write_reg_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_write_reg,CMockString_reg);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_reg, reg, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_write_reg,CMockString_val);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_val, val, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_write_reg(CMOCK_lora_write_reg_CALL_INSTANCE* cmock_call_instance, uint8_t reg, uint8_t val);
void CMockExpectParameters_lora_write_reg(CMOCK_lora_write_reg_CALL_INSTANCE* cmock_call_instance, uint8_t reg, uint8_t val)
{
  cmock_call_instance->Expected_reg = reg;
  cmock_call_instance->Expected_val = val;
}

void lora_write_reg_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t reg, uint8_t val, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_write_reg_CALL_INSTANCE));
  CMOCK_lora_write_reg_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_write_reg_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_write_reg_CallInstance = CMock_Guts_MemChain(Mock.lora_write_reg_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_write_reg(cmock_call_instance, reg, val);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_write_reg_buffer(uint8_t reg, uint8_t* val, uint8_t len)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_write_reg_buffer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_write_reg_buffer);
  cmock_call_instance = (CMOCK_lora_write_reg_buffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_write_reg_buffer_CallInstance);
  Mock.lora_write_reg_buffer_CallInstance = CMock_Guts_MemNext(Mock.lora_write_reg_buffer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_write_reg_buffer,CMockString_reg);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_reg, reg, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_write_reg_buffer,CMockString_val);
    if (cmock_call_instance->Expected_val == NULL)
      { UNITY_TEST_ASSERT_NULL(val, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_val, val, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_write_reg_buffer,CMockString_len);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_len, len, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_write_reg_buffer(CMOCK_lora_write_reg_buffer_CALL_INSTANCE* cmock_call_instance, uint8_t reg, uint8_t* val, uint8_t len);
void CMockExpectParameters_lora_write_reg_buffer(CMOCK_lora_write_reg_buffer_CALL_INSTANCE* cmock_call_instance, uint8_t reg, uint8_t* val, uint8_t len)
{
  cmock_call_instance->Expected_reg = reg;
  cmock_call_instance->Expected_val = val;
  cmock_call_instance->Expected_len = len;
}

void lora_write_reg_buffer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t reg, uint8_t* val, uint8_t len, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_write_reg_buffer_CALL_INSTANCE));
  CMOCK_lora_write_reg_buffer_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_write_reg_buffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_write_reg_buffer_CallInstance = CMock_Guts_MemChain(Mock.lora_write_reg_buffer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_write_reg_buffer(cmock_call_instance, reg, val, len);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_read_reg(uint8_t reg, uint8_t* val)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_read_reg_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_read_reg);
  cmock_call_instance = (CMOCK_lora_read_reg_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_read_reg_CallInstance);
  Mock.lora_read_reg_CallInstance = CMock_Guts_MemNext(Mock.lora_read_reg_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_read_reg,CMockString_reg);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_reg, reg, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_read_reg,CMockString_val);
    if (cmock_call_instance->Expected_val == NULL)
      { UNITY_TEST_ASSERT_NULL(val, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_val, val, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_read_reg(CMOCK_lora_read_reg_CALL_INSTANCE* cmock_call_instance, uint8_t reg, uint8_t* val);
void CMockExpectParameters_lora_read_reg(CMOCK_lora_read_reg_CALL_INSTANCE* cmock_call_instance, uint8_t reg, uint8_t* val)
{
  cmock_call_instance->Expected_reg = reg;
  cmock_call_instance->Expected_val = val;
}

void lora_read_reg_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t reg, uint8_t* val, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_read_reg_CALL_INSTANCE));
  CMOCK_lora_read_reg_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_read_reg_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_read_reg_CallInstance = CMock_Guts_MemChain(Mock.lora_read_reg_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_read_reg(cmock_call_instance, reg, val);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_read_reg_buffer(uint8_t reg, uint8_t* val, uint8_t len)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_read_reg_buffer_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_read_reg_buffer);
  cmock_call_instance = (CMOCK_lora_read_reg_buffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_read_reg_buffer_CallInstance);
  Mock.lora_read_reg_buffer_CallInstance = CMock_Guts_MemNext(Mock.lora_read_reg_buffer_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_read_reg_buffer,CMockString_reg);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_reg, reg, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_read_reg_buffer,CMockString_val);
    if (cmock_call_instance->Expected_val == NULL)
      { UNITY_TEST_ASSERT_NULL(val, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_val, val, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_read_reg_buffer,CMockString_len);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_len, len, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_read_reg_buffer(CMOCK_lora_read_reg_buffer_CALL_INSTANCE* cmock_call_instance, uint8_t reg, uint8_t* val, uint8_t len);
void CMockExpectParameters_lora_read_reg_buffer(CMOCK_lora_read_reg_buffer_CALL_INSTANCE* cmock_call_instance, uint8_t reg, uint8_t* val, uint8_t len)
{
  cmock_call_instance->Expected_reg = reg;
  cmock_call_instance->Expected_val = val;
  cmock_call_instance->Expected_len = len;
}

void lora_read_reg_buffer_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t reg, uint8_t* val, uint8_t len, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_read_reg_buffer_CALL_INSTANCE));
  CMOCK_lora_read_reg_buffer_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_read_reg_buffer_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_read_reg_buffer_CallInstance = CMock_Guts_MemChain(Mock.lora_read_reg_buffer_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_read_reg_buffer(cmock_call_instance, reg, val, len);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_explicit_header_mode(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_explicit_header_mode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_explicit_header_mode);
  cmock_call_instance = (CMOCK_lora_explicit_header_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_explicit_header_mode_CallInstance);
  Mock.lora_explicit_header_mode_CallInstance = CMock_Guts_MemNext(Mock.lora_explicit_header_mode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lora_explicit_header_mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_explicit_header_mode_CALL_INSTANCE));
  CMOCK_lora_explicit_header_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_explicit_header_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_explicit_header_mode_CallInstance = CMock_Guts_MemChain(Mock.lora_explicit_header_mode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_implicit_header_mode(uint8_t size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_implicit_header_mode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_implicit_header_mode);
  cmock_call_instance = (CMOCK_lora_implicit_header_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_implicit_header_mode_CallInstance);
  Mock.lora_implicit_header_mode_CallInstance = CMock_Guts_MemNext(Mock.lora_implicit_header_mode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_implicit_header_mode,CMockString_size);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_size, size, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_implicit_header_mode(CMOCK_lora_implicit_header_mode_CALL_INSTANCE* cmock_call_instance, uint8_t size);
void CMockExpectParameters_lora_implicit_header_mode(CMOCK_lora_implicit_header_mode_CALL_INSTANCE* cmock_call_instance, uint8_t size)
{
  cmock_call_instance->Expected_size = size;
}

void lora_implicit_header_mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t size, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_implicit_header_mode_CALL_INSTANCE));
  CMOCK_lora_implicit_header_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_implicit_header_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_implicit_header_mode_CallInstance = CMock_Guts_MemChain(Mock.lora_implicit_header_mode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_implicit_header_mode(cmock_call_instance, size);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_idle_mode(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_idle_mode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_idle_mode);
  cmock_call_instance = (CMOCK_lora_idle_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_idle_mode_CallInstance);
  Mock.lora_idle_mode_CallInstance = CMock_Guts_MemNext(Mock.lora_idle_mode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lora_idle_mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_idle_mode_CALL_INSTANCE));
  CMOCK_lora_idle_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_idle_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_idle_mode_CallInstance = CMock_Guts_MemChain(Mock.lora_idle_mode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_sleep_mode(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_sleep_mode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_sleep_mode);
  cmock_call_instance = (CMOCK_lora_sleep_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_sleep_mode_CallInstance);
  Mock.lora_sleep_mode_CallInstance = CMock_Guts_MemNext(Mock.lora_sleep_mode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lora_sleep_mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_sleep_mode_CALL_INSTANCE));
  CMOCK_lora_sleep_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_sleep_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_sleep_mode_CallInstance = CMock_Guts_MemChain(Mock.lora_sleep_mode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_receive_mode(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_receive_mode_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_receive_mode);
  cmock_call_instance = (CMOCK_lora_receive_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_receive_mode_CallInstance);
  Mock.lora_receive_mode_CallInstance = CMock_Guts_MemNext(Mock.lora_receive_mode_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lora_receive_mode_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_receive_mode_CALL_INSTANCE));
  CMOCK_lora_receive_mode_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_receive_mode_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_receive_mode_CallInstance = CMock_Guts_MemChain(Mock.lora_receive_mode_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_set_tx_power(uint8_t level)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_set_tx_power_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_set_tx_power);
  cmock_call_instance = (CMOCK_lora_set_tx_power_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_set_tx_power_CallInstance);
  Mock.lora_set_tx_power_CallInstance = CMock_Guts_MemNext(Mock.lora_set_tx_power_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_set_tx_power,CMockString_level);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_level, level, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_set_tx_power(CMOCK_lora_set_tx_power_CALL_INSTANCE* cmock_call_instance, uint8_t level);
void CMockExpectParameters_lora_set_tx_power(CMOCK_lora_set_tx_power_CALL_INSTANCE* cmock_call_instance, uint8_t level)
{
  cmock_call_instance->Expected_level = level;
}

void lora_set_tx_power_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t level, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_set_tx_power_CALL_INSTANCE));
  CMOCK_lora_set_tx_power_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_set_tx_power_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_set_tx_power_CallInstance = CMock_Guts_MemChain(Mock.lora_set_tx_power_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_set_tx_power(cmock_call_instance, level);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_set_frequency(long frequency)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_set_frequency_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_set_frequency);
  cmock_call_instance = (CMOCK_lora_set_frequency_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_set_frequency_CallInstance);
  Mock.lora_set_frequency_CallInstance = CMock_Guts_MemNext(Mock.lora_set_frequency_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_set_frequency,CMockString_frequency);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_frequency, frequency, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_set_frequency(CMOCK_lora_set_frequency_CALL_INSTANCE* cmock_call_instance, long frequency);
void CMockExpectParameters_lora_set_frequency(CMOCK_lora_set_frequency_CALL_INSTANCE* cmock_call_instance, long frequency)
{
  cmock_call_instance->Expected_frequency = frequency;
}

void lora_set_frequency_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, long frequency, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_set_frequency_CALL_INSTANCE));
  CMOCK_lora_set_frequency_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_set_frequency_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_set_frequency_CallInstance = CMock_Guts_MemChain(Mock.lora_set_frequency_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_set_frequency(cmock_call_instance, frequency);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_set_spreading_factor(uint8_t sf)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_set_spreading_factor_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_set_spreading_factor);
  cmock_call_instance = (CMOCK_lora_set_spreading_factor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_set_spreading_factor_CallInstance);
  Mock.lora_set_spreading_factor_CallInstance = CMock_Guts_MemNext(Mock.lora_set_spreading_factor_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_set_spreading_factor,CMockString_sf);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_sf, sf, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_set_spreading_factor(CMOCK_lora_set_spreading_factor_CALL_INSTANCE* cmock_call_instance, uint8_t sf);
void CMockExpectParameters_lora_set_spreading_factor(CMOCK_lora_set_spreading_factor_CALL_INSTANCE* cmock_call_instance, uint8_t sf)
{
  cmock_call_instance->Expected_sf = sf;
}

void lora_set_spreading_factor_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t sf, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_set_spreading_factor_CALL_INSTANCE));
  CMOCK_lora_set_spreading_factor_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_set_spreading_factor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_set_spreading_factor_CallInstance = CMock_Guts_MemChain(Mock.lora_set_spreading_factor_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_set_spreading_factor(cmock_call_instance, sf);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_get_spreading_factor(uint8_t* sf)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_get_spreading_factor_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_get_spreading_factor);
  cmock_call_instance = (CMOCK_lora_get_spreading_factor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_get_spreading_factor_CallInstance);
  Mock.lora_get_spreading_factor_CallInstance = CMock_Guts_MemNext(Mock.lora_get_spreading_factor_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_get_spreading_factor,CMockString_sf);
    if (cmock_call_instance->Expected_sf == NULL)
      { UNITY_TEST_ASSERT_NULL(sf, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_sf, sf, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_get_spreading_factor(CMOCK_lora_get_spreading_factor_CALL_INSTANCE* cmock_call_instance, uint8_t* sf);
void CMockExpectParameters_lora_get_spreading_factor(CMOCK_lora_get_spreading_factor_CALL_INSTANCE* cmock_call_instance, uint8_t* sf)
{
  cmock_call_instance->Expected_sf = sf;
}

void lora_get_spreading_factor_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* sf, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_get_spreading_factor_CALL_INSTANCE));
  CMOCK_lora_get_spreading_factor_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_get_spreading_factor_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_get_spreading_factor_CallInstance = CMock_Guts_MemChain(Mock.lora_get_spreading_factor_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_get_spreading_factor(cmock_call_instance, sf);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_set_dio_mapping(uint8_t dio, uint8_t mode)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_set_dio_mapping_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_set_dio_mapping);
  cmock_call_instance = (CMOCK_lora_set_dio_mapping_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_set_dio_mapping_CallInstance);
  Mock.lora_set_dio_mapping_CallInstance = CMock_Guts_MemNext(Mock.lora_set_dio_mapping_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_set_dio_mapping,CMockString_dio);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_dio, dio, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_set_dio_mapping,CMockString_mode);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_mode, mode, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_set_dio_mapping(CMOCK_lora_set_dio_mapping_CALL_INSTANCE* cmock_call_instance, uint8_t dio, uint8_t mode);
void CMockExpectParameters_lora_set_dio_mapping(CMOCK_lora_set_dio_mapping_CALL_INSTANCE* cmock_call_instance, uint8_t dio, uint8_t mode)
{
  cmock_call_instance->Expected_dio = dio;
  cmock_call_instance->Expected_mode = mode;
}

void lora_set_dio_mapping_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t dio, uint8_t mode, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_set_dio_mapping_CALL_INSTANCE));
  CMOCK_lora_set_dio_mapping_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_set_dio_mapping_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_set_dio_mapping_CallInstance = CMock_Guts_MemChain(Mock.lora_set_dio_mapping_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_set_dio_mapping(cmock_call_instance, dio, mode);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_get_dio_mapping(uint8_t dio, uint8_t* mapping)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_get_dio_mapping_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_get_dio_mapping);
  cmock_call_instance = (CMOCK_lora_get_dio_mapping_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_get_dio_mapping_CallInstance);
  Mock.lora_get_dio_mapping_CallInstance = CMock_Guts_MemNext(Mock.lora_get_dio_mapping_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_get_dio_mapping,CMockString_dio);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_dio, dio, cmock_line, CMockStringMismatch);
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_get_dio_mapping,CMockString_mapping);
    if (cmock_call_instance->Expected_mapping == NULL)
      { UNITY_TEST_ASSERT_NULL(mapping, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_mapping, mapping, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_get_dio_mapping(CMOCK_lora_get_dio_mapping_CALL_INSTANCE* cmock_call_instance, uint8_t dio, uint8_t* mapping);
void CMockExpectParameters_lora_get_dio_mapping(CMOCK_lora_get_dio_mapping_CALL_INSTANCE* cmock_call_instance, uint8_t dio, uint8_t* mapping)
{
  cmock_call_instance->Expected_dio = dio;
  cmock_call_instance->Expected_mapping = mapping;
}

void lora_get_dio_mapping_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t dio, uint8_t* mapping, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_get_dio_mapping_CALL_INSTANCE));
  CMOCK_lora_get_dio_mapping_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_get_dio_mapping_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_get_dio_mapping_CallInstance = CMock_Guts_MemChain(Mock.lora_get_dio_mapping_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_get_dio_mapping(cmock_call_instance, dio, mapping);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_set_bandwidth(uint8_t sbw)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_set_bandwidth_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_set_bandwidth);
  cmock_call_instance = (CMOCK_lora_set_bandwidth_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_set_bandwidth_CallInstance);
  Mock.lora_set_bandwidth_CallInstance = CMock_Guts_MemNext(Mock.lora_set_bandwidth_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_set_bandwidth,CMockString_sbw);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_sbw, sbw, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_set_bandwidth(CMOCK_lora_set_bandwidth_CALL_INSTANCE* cmock_call_instance, uint8_t sbw);
void CMockExpectParameters_lora_set_bandwidth(CMOCK_lora_set_bandwidth_CALL_INSTANCE* cmock_call_instance, uint8_t sbw)
{
  cmock_call_instance->Expected_sbw = sbw;
}

void lora_set_bandwidth_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t sbw, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_set_bandwidth_CALL_INSTANCE));
  CMOCK_lora_set_bandwidth_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_set_bandwidth_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_set_bandwidth_CallInstance = CMock_Guts_MemChain(Mock.lora_set_bandwidth_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_set_bandwidth(cmock_call_instance, sbw);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_get_bandwidth(uint8_t* sbw)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_get_bandwidth_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_get_bandwidth);
  cmock_call_instance = (CMOCK_lora_get_bandwidth_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_get_bandwidth_CallInstance);
  Mock.lora_get_bandwidth_CallInstance = CMock_Guts_MemNext(Mock.lora_get_bandwidth_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_get_bandwidth,CMockString_sbw);
    if (cmock_call_instance->Expected_sbw == NULL)
      { UNITY_TEST_ASSERT_NULL(sbw, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_sbw, sbw, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_get_bandwidth(CMOCK_lora_get_bandwidth_CALL_INSTANCE* cmock_call_instance, uint8_t* sbw);
void CMockExpectParameters_lora_get_bandwidth(CMOCK_lora_get_bandwidth_CALL_INSTANCE* cmock_call_instance, uint8_t* sbw)
{
  cmock_call_instance->Expected_sbw = sbw;
}

void lora_get_bandwidth_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* sbw, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_get_bandwidth_CALL_INSTANCE));
  CMOCK_lora_get_bandwidth_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_get_bandwidth_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_get_bandwidth_CallInstance = CMock_Guts_MemChain(Mock.lora_get_bandwidth_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_get_bandwidth(cmock_call_instance, sbw);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_set_coding_rate(uint8_t denominator)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_set_coding_rate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_set_coding_rate);
  cmock_call_instance = (CMOCK_lora_set_coding_rate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_set_coding_rate_CallInstance);
  Mock.lora_set_coding_rate_CallInstance = CMock_Guts_MemNext(Mock.lora_set_coding_rate_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_set_coding_rate,CMockString_denominator);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_denominator, denominator, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_set_coding_rate(CMOCK_lora_set_coding_rate_CALL_INSTANCE* cmock_call_instance, uint8_t denominator);
void CMockExpectParameters_lora_set_coding_rate(CMOCK_lora_set_coding_rate_CALL_INSTANCE* cmock_call_instance, uint8_t denominator)
{
  cmock_call_instance->Expected_denominator = denominator;
}

void lora_set_coding_rate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t denominator, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_set_coding_rate_CALL_INSTANCE));
  CMOCK_lora_set_coding_rate_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_set_coding_rate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_set_coding_rate_CallInstance = CMock_Guts_MemChain(Mock.lora_set_coding_rate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_set_coding_rate(cmock_call_instance, denominator);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_get_coding_rate(uint8_t* cr)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_get_coding_rate_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_get_coding_rate);
  cmock_call_instance = (CMOCK_lora_get_coding_rate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_get_coding_rate_CallInstance);
  Mock.lora_get_coding_rate_CallInstance = CMock_Guts_MemNext(Mock.lora_get_coding_rate_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_get_coding_rate,CMockString_cr);
    if (cmock_call_instance->Expected_cr == NULL)
      { UNITY_TEST_ASSERT_NULL(cr, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_cr, cr, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_get_coding_rate(CMOCK_lora_get_coding_rate_CALL_INSTANCE* cmock_call_instance, uint8_t* cr);
void CMockExpectParameters_lora_get_coding_rate(CMOCK_lora_get_coding_rate_CALL_INSTANCE* cmock_call_instance, uint8_t* cr)
{
  cmock_call_instance->Expected_cr = cr;
}

void lora_get_coding_rate_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* cr, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_get_coding_rate_CALL_INSTANCE));
  CMOCK_lora_get_coding_rate_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_get_coding_rate_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_get_coding_rate_CallInstance = CMock_Guts_MemChain(Mock.lora_get_coding_rate_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_get_coding_rate(cmock_call_instance, cr);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_set_preamble_length(long length)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_set_preamble_length_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_set_preamble_length);
  cmock_call_instance = (CMOCK_lora_set_preamble_length_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_set_preamble_length_CallInstance);
  Mock.lora_set_preamble_length_CallInstance = CMock_Guts_MemNext(Mock.lora_set_preamble_length_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_set_preamble_length,CMockString_length);
    UNITY_TEST_ASSERT_EQUAL_INT(cmock_call_instance->Expected_length, length, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_set_preamble_length(CMOCK_lora_set_preamble_length_CALL_INSTANCE* cmock_call_instance, long length);
void CMockExpectParameters_lora_set_preamble_length(CMOCK_lora_set_preamble_length_CALL_INSTANCE* cmock_call_instance, long length)
{
  cmock_call_instance->Expected_length = length;
}

void lora_set_preamble_length_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, long length, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_set_preamble_length_CALL_INSTANCE));
  CMOCK_lora_set_preamble_length_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_set_preamble_length_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_set_preamble_length_CallInstance = CMock_Guts_MemChain(Mock.lora_set_preamble_length_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_set_preamble_length(cmock_call_instance, length);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_get_preamble_length(long* preamble)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_get_preamble_length_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_get_preamble_length);
  cmock_call_instance = (CMOCK_lora_get_preamble_length_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_get_preamble_length_CallInstance);
  Mock.lora_get_preamble_length_CallInstance = CMock_Guts_MemNext(Mock.lora_get_preamble_length_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_get_preamble_length,CMockString_preamble);
    if (cmock_call_instance->Expected_preamble == NULL)
      { UNITY_TEST_ASSERT_NULL(preamble, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_preamble, preamble, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_get_preamble_length(CMOCK_lora_get_preamble_length_CALL_INSTANCE* cmock_call_instance, long* preamble);
void CMockExpectParameters_lora_get_preamble_length(CMOCK_lora_get_preamble_length_CALL_INSTANCE* cmock_call_instance, long* preamble)
{
  cmock_call_instance->Expected_preamble = preamble;
}

void lora_get_preamble_length_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, long* preamble, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_get_preamble_length_CALL_INSTANCE));
  CMOCK_lora_get_preamble_length_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_get_preamble_length_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_get_preamble_length_CallInstance = CMock_Guts_MemChain(Mock.lora_get_preamble_length_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_get_preamble_length(cmock_call_instance, preamble);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_set_sync_word(uint8_t sw)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_set_sync_word_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_set_sync_word);
  cmock_call_instance = (CMOCK_lora_set_sync_word_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_set_sync_word_CallInstance);
  Mock.lora_set_sync_word_CallInstance = CMock_Guts_MemNext(Mock.lora_set_sync_word_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_set_sync_word,CMockString_sw);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_sw, sw, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_set_sync_word(CMOCK_lora_set_sync_word_CALL_INSTANCE* cmock_call_instance, uint8_t sw);
void CMockExpectParameters_lora_set_sync_word(CMOCK_lora_set_sync_word_CALL_INSTANCE* cmock_call_instance, uint8_t sw)
{
  cmock_call_instance->Expected_sw = sw;
}

void lora_set_sync_word_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t sw, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_set_sync_word_CALL_INSTANCE));
  CMOCK_lora_set_sync_word_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_set_sync_word_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_set_sync_word_CallInstance = CMock_Guts_MemChain(Mock.lora_set_sync_word_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_set_sync_word(cmock_call_instance, sw);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_enable_crc(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_enable_crc_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_enable_crc);
  cmock_call_instance = (CMOCK_lora_enable_crc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_enable_crc_CallInstance);
  Mock.lora_enable_crc_CallInstance = CMock_Guts_MemNext(Mock.lora_enable_crc_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lora_enable_crc_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_enable_crc_CALL_INSTANCE));
  CMOCK_lora_enable_crc_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_enable_crc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_enable_crc_CallInstance = CMock_Guts_MemChain(Mock.lora_enable_crc_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_disable_crc(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_disable_crc_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_disable_crc);
  cmock_call_instance = (CMOCK_lora_disable_crc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_disable_crc_CallInstance);
  Mock.lora_disable_crc_CallInstance = CMock_Guts_MemNext(Mock.lora_disable_crc_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lora_disable_crc_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_disable_crc_CALL_INSTANCE));
  CMOCK_lora_disable_crc_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_disable_crc_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_disable_crc_CallInstance = CMock_Guts_MemChain(Mock.lora_disable_crc_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_driver_init(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_driver_init_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_driver_init);
  cmock_call_instance = (CMOCK_lora_driver_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_driver_init_CallInstance);
  Mock.lora_driver_init_CallInstance = CMock_Guts_MemNext(Mock.lora_driver_init_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lora_driver_init_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_driver_init_CALL_INSTANCE));
  CMOCK_lora_driver_init_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_driver_init_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_driver_init_CallInstance = CMock_Guts_MemChain(Mock.lora_driver_init_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_send_packet(uint8_t* buf, uint8_t size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_send_packet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_send_packet);
  cmock_call_instance = (CMOCK_lora_send_packet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_send_packet_CallInstance);
  Mock.lora_send_packet_CallInstance = CMock_Guts_MemNext(Mock.lora_send_packet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_send_packet,CMockString_buf);
    if (cmock_call_instance->Expected_buf == NULL)
      { UNITY_TEST_ASSERT_NULL(buf, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buf, buf, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_send_packet,CMockString_size);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_size, size, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_send_packet(CMOCK_lora_send_packet_CALL_INSTANCE* cmock_call_instance, uint8_t* buf, uint8_t size);
void CMockExpectParameters_lora_send_packet(CMOCK_lora_send_packet_CALL_INSTANCE* cmock_call_instance, uint8_t* buf, uint8_t size)
{
  cmock_call_instance->Expected_buf = buf;
  cmock_call_instance->Expected_size = size;
}

void lora_send_packet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* buf, uint8_t size, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_send_packet_CALL_INSTANCE));
  CMOCK_lora_send_packet_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_send_packet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_send_packet_CallInstance = CMock_Guts_MemChain(Mock.lora_send_packet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_send_packet(cmock_call_instance, buf, size);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_receive_packet(uint8_t* buf, uint8_t* return_len, uint8_t size)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_receive_packet_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_receive_packet);
  cmock_call_instance = (CMOCK_lora_receive_packet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_receive_packet_CallInstance);
  Mock.lora_receive_packet_CallInstance = CMock_Guts_MemNext(Mock.lora_receive_packet_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_receive_packet,CMockString_buf);
    if (cmock_call_instance->Expected_buf == NULL)
      { UNITY_TEST_ASSERT_NULL(buf, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_buf, buf, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_receive_packet,CMockString_return_len);
    if (cmock_call_instance->Expected_return_len == NULL)
      { UNITY_TEST_ASSERT_NULL(return_len, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_return_len, return_len, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_receive_packet,CMockString_size);
    UNITY_TEST_ASSERT_EQUAL_HEX8(cmock_call_instance->Expected_size, size, cmock_line, CMockStringMismatch);
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_receive_packet(CMOCK_lora_receive_packet_CALL_INSTANCE* cmock_call_instance, uint8_t* buf, uint8_t* return_len, uint8_t size);
void CMockExpectParameters_lora_receive_packet(CMOCK_lora_receive_packet_CALL_INSTANCE* cmock_call_instance, uint8_t* buf, uint8_t* return_len, uint8_t size)
{
  cmock_call_instance->Expected_buf = buf;
  cmock_call_instance->Expected_return_len = return_len;
  cmock_call_instance->Expected_size = size;
}

void lora_receive_packet_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* buf, uint8_t* return_len, uint8_t size, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_receive_packet_CALL_INSTANCE));
  CMOCK_lora_receive_packet_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_receive_packet_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_receive_packet_CallInstance = CMock_Guts_MemChain(Mock.lora_receive_packet_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_receive_packet(cmock_call_instance, buf, return_len, size);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_received(bool* received, bool* crc_error)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_received_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_received);
  cmock_call_instance = (CMOCK_lora_received_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_received_CallInstance);
  Mock.lora_received_CallInstance = CMock_Guts_MemNext(Mock.lora_received_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_received,CMockString_received);
    if (cmock_call_instance->Expected_received == NULL)
      { UNITY_TEST_ASSERT_NULL(received, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_received, received, 1, cmock_line, CMockStringMismatch); }
  }
  {
    UNITY_SET_DETAILS(CMockString_lora_received,CMockString_crc_error);
    if (cmock_call_instance->Expected_crc_error == NULL)
      { UNITY_TEST_ASSERT_NULL(crc_error, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_INT_ARRAY(cmock_call_instance->Expected_crc_error, crc_error, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_received(CMOCK_lora_received_CALL_INSTANCE* cmock_call_instance, bool* received, bool* crc_error);
void CMockExpectParameters_lora_received(CMOCK_lora_received_CALL_INSTANCE* cmock_call_instance, bool* received, bool* crc_error)
{
  cmock_call_instance->Expected_received = received;
  cmock_call_instance->Expected_crc_error = crc_error;
}

void lora_received_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, bool* received, bool* crc_error, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_received_CALL_INSTANCE));
  CMOCK_lora_received_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_received_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_received_CallInstance = CMock_Guts_MemChain(Mock.lora_received_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_received(cmock_call_instance, received, crc_error);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_get_irq(uint8_t* irq_flags)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_get_irq_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_get_irq);
  cmock_call_instance = (CMOCK_lora_get_irq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_get_irq_CallInstance);
  Mock.lora_get_irq_CallInstance = CMock_Guts_MemNext(Mock.lora_get_irq_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_get_irq,CMockString_irq_flags);
    if (cmock_call_instance->Expected_irq_flags == NULL)
      { UNITY_TEST_ASSERT_NULL(irq_flags, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_irq_flags, irq_flags, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_get_irq(CMOCK_lora_get_irq_CALL_INSTANCE* cmock_call_instance, uint8_t* irq_flags);
void CMockExpectParameters_lora_get_irq(CMOCK_lora_get_irq_CALL_INSTANCE* cmock_call_instance, uint8_t* irq_flags)
{
  cmock_call_instance->Expected_irq_flags = irq_flags;
}

void lora_get_irq_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* irq_flags, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_get_irq_CALL_INSTANCE));
  CMOCK_lora_get_irq_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_get_irq_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_get_irq_CallInstance = CMock_Guts_MemChain(Mock.lora_get_irq_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_get_irq(cmock_call_instance, irq_flags);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

uint8_t lora_packet_lost(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_packet_lost_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_packet_lost);
  cmock_call_instance = (CMOCK_lora_packet_lost_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_packet_lost_CallInstance);
  Mock.lora_packet_lost_CallInstance = CMock_Guts_MemNext(Mock.lora_packet_lost_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lora_packet_lost_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_packet_lost_CALL_INSTANCE));
  CMOCK_lora_packet_lost_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_packet_lost_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_packet_lost_CallInstance = CMock_Guts_MemChain(Mock.lora_packet_lost_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  cmock_call_instance->ReturnVal = cmock_to_return;
}

lora_status_t lora_packet_rssi(uint8_t* rssi)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_packet_rssi_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_packet_rssi);
  cmock_call_instance = (CMOCK_lora_packet_rssi_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_packet_rssi_CallInstance);
  Mock.lora_packet_rssi_CallInstance = CMock_Guts_MemNext(Mock.lora_packet_rssi_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_packet_rssi,CMockString_rssi);
    if (cmock_call_instance->Expected_rssi == NULL)
      { UNITY_TEST_ASSERT_NULL(rssi, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_rssi, rssi, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_packet_rssi(CMOCK_lora_packet_rssi_CALL_INSTANCE* cmock_call_instance, uint8_t* rssi);
void CMockExpectParameters_lora_packet_rssi(CMOCK_lora_packet_rssi_CALL_INSTANCE* cmock_call_instance, uint8_t* rssi)
{
  cmock_call_instance->Expected_rssi = rssi;
}

void lora_packet_rssi_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* rssi, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_packet_rssi_CALL_INSTANCE));
  CMOCK_lora_packet_rssi_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_packet_rssi_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_packet_rssi_CallInstance = CMock_Guts_MemChain(Mock.lora_packet_rssi_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_packet_rssi(cmock_call_instance, rssi);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

lora_status_t lora_packet_snr(uint8_t* snr)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_packet_snr_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_packet_snr);
  cmock_call_instance = (CMOCK_lora_packet_snr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_packet_snr_CallInstance);
  Mock.lora_packet_snr_CallInstance = CMock_Guts_MemNext(Mock.lora_packet_snr_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  {
    UNITY_SET_DETAILS(CMockString_lora_packet_snr,CMockString_snr);
    if (cmock_call_instance->Expected_snr == NULL)
      { UNITY_TEST_ASSERT_NULL(snr, cmock_line, CMockStringExpNULL); }
    else
      { UNITY_TEST_ASSERT_EQUAL_HEX8_ARRAY(cmock_call_instance->Expected_snr, snr, 1, cmock_line, CMockStringMismatch); }
  }
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void CMockExpectParameters_lora_packet_snr(CMOCK_lora_packet_snr_CALL_INSTANCE* cmock_call_instance, uint8_t* snr);
void CMockExpectParameters_lora_packet_snr(CMOCK_lora_packet_snr_CALL_INSTANCE* cmock_call_instance, uint8_t* snr)
{
  cmock_call_instance->Expected_snr = snr;
}

void lora_packet_snr_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, uint8_t* snr, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_packet_snr_CALL_INSTANCE));
  CMOCK_lora_packet_snr_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_packet_snr_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_packet_snr_CallInstance = CMock_Guts_MemChain(Mock.lora_packet_snr_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  CMockExpectParameters_lora_packet_snr(cmock_call_instance, snr);
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

void lora_close(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_close_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_close);
  cmock_call_instance = (CMOCK_lora_close_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_close_CallInstance);
  Mock.lora_close_CallInstance = CMock_Guts_MemNext(Mock.lora_close_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
}

void lora_close_CMockExpect(UNITY_LINE_TYPE cmock_line)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_close_CALL_INSTANCE));
  CMOCK_lora_close_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_close_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_close_CallInstance = CMock_Guts_MemChain(Mock.lora_close_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
}

lora_status_t lora_dump_registers(void)
{
  UNITY_LINE_TYPE cmock_line = TEST_LINE_NUM;
  CMOCK_lora_dump_registers_CALL_INSTANCE* cmock_call_instance;
  UNITY_SET_DETAIL(CMockString_lora_dump_registers);
  cmock_call_instance = (CMOCK_lora_dump_registers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(Mock.lora_dump_registers_CallInstance);
  Mock.lora_dump_registers_CallInstance = CMock_Guts_MemNext(Mock.lora_dump_registers_CallInstance);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringCalledMore);
  cmock_line = cmock_call_instance->LineNumber;
  UNITY_CLR_DETAILS();
  return cmock_call_instance->ReturnVal;
}

void lora_dump_registers_CMockExpectAndReturn(UNITY_LINE_TYPE cmock_line, lora_status_t cmock_to_return)
{
  CMOCK_MEM_INDEX_TYPE cmock_guts_index = CMock_Guts_MemNew(sizeof(CMOCK_lora_dump_registers_CALL_INSTANCE));
  CMOCK_lora_dump_registers_CALL_INSTANCE* cmock_call_instance = (CMOCK_lora_dump_registers_CALL_INSTANCE*)CMock_Guts_GetAddressFor(cmock_guts_index);
  UNITY_TEST_ASSERT_NOT_NULL(cmock_call_instance, cmock_line, CMockStringOutOfMemory);
  memset(cmock_call_instance, 0, sizeof(*cmock_call_instance));
  Mock.lora_dump_registers_CallInstance = CMock_Guts_MemChain(Mock.lora_dump_registers_CallInstance, cmock_guts_index);
  cmock_call_instance->LineNumber = cmock_line;
  memcpy((void*)(&cmock_call_instance->ReturnVal), (void*)(&cmock_to_return),
         sizeof(lora_status_t[sizeof(cmock_to_return) == sizeof(lora_status_t) ? 1 : -1])); /* add lora_status_t to :treat_as_array if this causes an error */
}

